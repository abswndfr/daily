
So, in this lecture, let's understand the container_of macro by creating our a own container_of a macro.

If you have understood how it works, then no problem, you can skip this lecture.

Basically, we are understanding something from scratch.

First of all, let's say you have a structure. This is a structure definition and here I have a structure

variable data. And there is a function called init, where I have initialized all the member elements of

this structure variable. After that,

here is a function call, and here I'm passing the address of one of the member element. For example,

'c' is a member element.

I'm passing the address of that member element. Here, remember that, c is a member. So, who is a container_of

c? That is data. Data is a container remember.

This is a member,

this is container.

Once I pass that address to some other function, this function may be defined in some other file let's say.

So, the address will be received at this variable.

What have to do is, using this pointer

you have to get back the address of it's container.Who is it's container?

This one.

Right?

That is a task. For that purpose,

we actually use the macro container_of. container_of

this pointer.

At this pointer holds the address of one of its members, the members c. What have to do is, you just

have to you know first pass the pointer, so address of the member element. The member element in this case is

c. And this should be the structure type. The structure type is struct some_data and the third argument

should be the member name to which this 'ptr' refers to. Member name is

c. If you give this much information, that container_of macro will calculate the containers address

and it will give you the container address. Fair enough.Now,

let's do one exercise.

Now, let's create our own version of container_of macro.

Here, I have a small program. So, I just use a online tool to write some code.

Here it is a struct and this is a variable.

And this is a main, where I initialize everything. I pass the address of the member element 'c' to this function.

By using the 'ptr' get the address of its container. Here, you should be doing some a manipulation over the

structure and it's various a addresses of the member elements.

To do this exercise, you first understand the memory plot of this variable. How the memory plot of

this variable looks like?

Here is a memory plot of struct variable data.

Data has 4 variables.

The first 4 bytes will be consumed for this variable char.

This grey area is actually padding. Basically, the char a actually consumes 4 bytes here, and int b

consumes

next four bytes, char c consumes next 4 bytes. Actually it consumes only one byte rest of for padding. Because, as you

may be knowing in an unpacked structure, the variable will always occupy the natural size boundary.

That's why, it looks something like this.

Collectively, it this structure actually consumes a 12 bytes.

Let's say, its address is 0x100.

0x100 also happens to be the address of the first member element, that is a.

Which we can also call it as a container address. And this is b, which comes at 0x104,

this is a address of the member element b, likewise, this is a address of the member element c,

and this is a member element d's address.

So, now you have this address, isn't it?

You want to calculate its container address. The container address is 100.

How do you calculate? So, you know this address, you take that let's keep it as X, you have to subtract

something.

What you will be subtracting is this variables offset from the beginning.

How many offset away this c is from the beginning? You have to calculate. 4+4

Right

8

All you need to do is X-8. X is 108.

So, 108-8 will give you the value of this container.

That's what container_of macro does. That's it.

Now, let's see how to reused that using a some piece of code.

First of all, we have this address, isn't it?

All we need to do now is, we have to calculate member(c) offset from the beginning. That's it. And just

subtract that from the address,

you get the containers address.

Let me create one variable to store the offset. offset.

So, offset = how do you calculate the offset? So, to calculate the offset, I just create one temporary

variable of this struct.

Struct some_data temp or something like that. And now, what I do is, I take the address of the member

element in which I'm interested.

That's why, by taking the member element c's address we have to reduce the containers address.

That's why, I have to calculate the offset between the member element 'c' and the beginning.

That's why, what I do is, I first take the address of the member element in which I am interested minus beginning.

Beginning is temp.a. I would typecast this to char *.

Let's make it everything char *.

This gives me one quantity a value. Basically, this will be a pointer type, this result will be of pointer

type.

I have to convert that into a value.

Let me just type that into int.

Now, I got the offset here.

For example, if this address is 108 and this address is 100, then

108-100, so 8 will be stored here. That's a offset. And then, I have to subtract this offset

value from this pointer. That's it.

I would create a

another variable to store the containers address struct some_data.

Let me create a variable

let's say data1 = this ptr -

this offset.

So, I have to typecast this is a pointer arithmetic.

This will result in pointer quantity.

That's why, I have to typecast this to

struct some_data*.

Now, you got the containers address here. That means, the address which is same as its base address.

So, this variables base address.

Let's print all these details using this pointer.

That's it. Now, let's run this code,

let's see what happens.

You can see that, by using this pointer you are successful in printing the details of this container variable.

10, 5, a, 100. But here, I have used one extra variable.

Actually, using this extra variable is not required,

you can use something called as 0 dereferencing.

Here, what we did was, we calculated this difference by taking this local variables address as a reference.

Instead of that, you can remove this and you can take 0 as a reference.

What I do here is,

So, I will remove this first of all. I will take zero as a reference. And I will typecast this 0

to struct some_data*.

Now, I converted this 0 into a pointer of this type

and I select the member element in which I'm interested c.

And here you should be careful, you have to put one more parenthesis here.Like this.

You took zero as a reference.

And this is not a dereferencing remember.

So, you are not dereferencing and you are reading the value of c, something like that.

It's not like that.

If you try to do that, then there could be a segmentation fault.

Here, we are just evaluating the address of the c with respect to the reference 0.

That's why, we have to use &(ampersand) here.

This is not a dereferencing operation

remember that. Some of you may be having doubt that this would lead in segmentation fault, this won't

lead to segmentation.

So, if you remove this, then this will lead to segmentation fault. Because, it's like reading the value

of 'c' by dereferencing 0.

But, if you give ampersand(&) here, the compiler will generate the instructions to calculate

c's address. c's address with respect to this as a base, 0 as a base.

Now, here we get the address of c, isn't it? We have to subtract the address of the beginning.

But beginning is 0 in our case.

Why?

Because, we took 0 as a reference.

That's why, if you take the beginning, then that would become redundant.

So, that's why, you need not to subtract here.

So, now let's run this code and you can see that you get the same result.

You get the values of the container. So, it actually shows one warning here. That's because, the compiler

is saying to consider this as a long. So, you can consider this as a long.

Let's try this.

If you want to get the container address by using the variable let's say b, then you have to pass b

here. And here, you have to change this variable.

That's a reason, why container_of takes member name.

You have to modify this to b.

And then everything will be the same.

Here, it says the incompatible one. Because, you have to typecast this to char*. Because, the receiving

is char*, b is actually of integer.

Right?

How to make this as a generic macro?

It's a c function, now let's convert this into a macro.

Let's write our own container_of macro.

define container_of

So, you would need a pointer.

Pointer, and you need a member name, and a struct type to typecast. That's a reason you have to take

struct type and member name.

So, the final output of this macro should be a pointer of this type.

Let me write that first type*.

It should be a type*.

Here, you should be doing

this one. ptr - offset.

ptr - offset. Offset,

this is how we calculated the offset.

You have to take the 0 as a base,

dereference member.

This 0 has to be typecast it.

Let's typecast

to type*.

That's great.

Now keep this quantity in another parenthesis

and you need its address, so ampersand. Pointer minus this quantity.

Both should be of same data type.

That's why,

let's convert them into a char* data type. Char* and this quantity as well. Convert that into a char*.

This is a first quantity and this is a second quantity.

And the result will be typecasted to type*.

That looks good.

Now put everything in another parenthesis.

So now, we can

remove all these things.

Let me disable this code block.

And let's get the container address at this variable using our container_of macro. Container_of (ptr,

struct some_data).

Instead of doing this here, I would cut this code and I would do that here itself.

This function is not required now. I would remove this code, I would do that main here, here itself.

Data1, container_of(ptr,strut some_data) so the member of your choice.

The ptr now becomes any address of the member. Let's say,

&data.b. And the member element name you should give here.

That's it.

Let's run.

Yes, you can see that, we get the same values.

Now, let's change this to c.

You just created your own version of container_of.

If you see a Linux source code, you see something similar, but there is a type checking as well.

If you check a linux source code here. So, this is something similar,

we can see that, they are using a offset macro here, offsetof.

This is a pointer what you supplied.

You can see here, pointer is equated to this pointer and they are subtracting the offset. The offset they are

calculating by using this offset macro.

You can also use that.

I will show you that.

Actually, there is a offset macro in kernel.h.

You just have to supply the TYPE and MEMBER. You have to just pass in the structure type and the member.

It just calculates the offset of this member by doing a 0 dereferencing, what you just did in your program.

So, that's why, you can also use here the offsetof macro.

Instead of this quantity you can use offsetof macro.

Let me use that.

What I'm going to do is, I'm going to remove all these things. I just use offsetof(type, member).

This type and member.

So, this actually returns a number not pointer. It actually returns a number of long type.

To include this macro, actually the standard library also gives this macro. You should include

stddef.h. Where as this macro you find in kernel.h, it is kernels own version of offsetof

macro. While doing kernel programming or device driver programming

you should use a this header file to get this macro.

Let's run.

And the result will be the same, no difference.

Now, here this actually returns a number, right? a number quantity not a pointer.

Let's make this also a number quantity, not a pointer.

I would typecast this with long.

So, this is now a value - value.

not pointer - pointer.

Let's run this.

Now, you get the same answer.

Let's try with some other thing. Let's give 'd' here, and the member element name is d. Let's try.

Let's change some values here and let's try.

So, that's how the container_of macro works, and I hope you get some idea about container_of macro.

The linux container_of maco, which is defined in kernel.h also does something similar.

You can see here, there is a offset subtraction from the supplied pointer.

But, in between it does a type checking. For example, if this pointers data type, if it doesn't

match with this members pointer data type, then it warns you saying "pointer type mismatch in container_of()".

This is actually a check.

So, with that note, I would like to end this lecture on container_of() and I'll see you in the next

lecture.

