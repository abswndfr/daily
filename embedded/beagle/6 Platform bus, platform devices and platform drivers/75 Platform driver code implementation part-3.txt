slids 253




In the previous lecture, we started coding for our platform_driver. Now, in this lecture,

let's discuss about the data structure what we're going to use.

I'm going to again a use this model a device private data structure and driver private data structure.

This is something similar to what you saw in the previous exercise,

but I have done some minor modifications here.

First of all, let's talk about the driver private data structure.

It a holds some drivers specific data like a total number of devices, it is managing.And I'm going to

propose one new a member element here, that is device_num_base.

And I use this a variable to hold the base of the device_number.

When I use a alloc_chrdev_region, I'm going to use this a device_num_base as an input argument.

It actually holds the base of the device_number.

And after that, as usual, you have a class pointer and device pointer here.

This will be our device private data structure.Whenever a device is detected or whenever there is a match in

the platform device, you know that a probe function will get called.

So, if there are 10 match devices, then 10 times you are probe function will get called. Each time

I'm going to allocate memory dynamically to the device private data structure.

This is how the device private data structure looks like.

So, the first member element is a platform data.Because, you know that, platform device gives you

some platform specific data.

In our case, it is size, a permission, and some device serial number, something like that.

Right?

You need to store that.

That's why, I'm going to use this a 'pdata' variable. struct pcdev_platform_data, which is defined in

platform.h.

And after that, this is a pointer to hold the address to the device private buffer.

Again, we are going to allocate memory to this buffer dynamically.

And after that, this dev_num variable stores the real device number of the device. And of course, this is cdev,

this is the next member element, which is required for the character device registration.

And after that, let's get back to our code and we have to now code several functions.We have to

code our init function, we have to code our cleanup function,

and after that, we are going to code the probe function and remove function.

So, I have written comments here to help you understand what we are going to do next.

And in this file, I also added the device private data structure and driver private data structure.

Let's create a variable of our driver private data structure.

For the driver, we are going to create one variable globally. But for the device, we will create

dynamically, whenever our probe function gets called.

That makes sense for this exercise.

I'm not going to allocate any memory for this as of now.

I'm going to create the variables only when a platform device is detected.

Let's create a variable for driver data structure. struct

pcdrv_private_data

I call it as pcdrv_data.

It's a global variable.

First, let's start coding from our init function.

The first thing what we do in init function is dynamically allocate a device number for MAX_DEVICES.

We are going to maintain one macro here, MAX_DEVICES and we are going to use a

alloc_chrdev_region to support MAX_DEVICES.

Let's use a this alloc_chrdev_region.By the way, I'm taking some code from my earlier project pcd_n.

Basically, we have to use this

alloc_chrdev_region. Let's use that.

Remove this variable here, and I call it this macro as MAX_DEVICE.

I'm going to keep the same name pcdev. Here,

you should give a pointer to store the base of the device.

number.

And for that, we are going to use this variable of driver private data structure, device_num_base.

Let's use that.

pcdrv_data.device

num_base.Let's

create a variable return.

And after that, if return fails, then you should quit. Let's copy this code as well.

So, if return is less than 0, then it's an error.

Let's just return here.

And after that, the next step is create device class under /sys/class.

These are one time creations.

That's a reason, why I keep them in init function not in probe function. Probe executes multiple times.

We need not to do these things multiple times.

So, that's why, let's create a device class here.

pcdrv_data.class_pcd = class_create, pcd_class. And if there is any error, then class creation is failed.

What you should be doing? Now is

let me remove this goto.

You just have to call unregister_chrdev_region. Let's do that here itself.

Here, I am going to use unregister_chrdev_region, pcdrv_data and I'm going to mention the device_num_base and the

MAX_DEVICES macro.

Let's create that macro here.

MAX_DEVICES. Let's use 10.

And after that, here return the error code.And the third step is register your platform

driver.

Here, we are not doing any error checking for platform_driver_register, for a time being I just

avoid that.

Of course, you should do a error checking for platform_driver.So, if that is negative, then you should

undo all these things.

That's how we are going to use our init function.

And now let's implement the cleanup function.In the cleanup function, first we are going to unregister

the platform driver.

And after that, destroy the class. And unregister device number using unregister_chrdev_region.

We used class_destroy and unregister_chrdev_region.The same thing we are going to use here as well.

So, I'm going to copy these two lines and I'm going to keep that here.

Let's do some modification here.

This is pcdrv_data, device_num_base,

and MAX_DEVICES.

That looks good.

Let's save this project and let's try to build.Yes,

if there are no issues with the code.And complete upto here and in the next lecture, let's code for

probe.

I'll see you in the next lecture.

