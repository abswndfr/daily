
Hey, welcome back. In the previous couple of lectures, so you understood how to write a simple linux

kernel module and you learnt various syntaxes involved. And you also learnt how to create device files and how

to communicate from the user space with a driver.

In this section, I'm going to cover another important concept of a linux device driver programming,

that is a platform devices and drivers. We are going to write some platform drivers and we are going

to test it on our board.

Platform drivers deal with platform devices. Platform drivers could be a character driver, or it could

be a block driver, or a network driver.

It could be anything. Basically, a driver which deals with a real device of the platform.

That's called a platform driver.

And it has certain syntaxes to follow and it has its own data structures to follow,

we are going to explore all those things in this section.

First, let's discuss what exactly is a platform bus. And after that, will discuss platform devices

and platform drivers.

In computer science, a bus is nothing but it's a collection of electrical wirings which transfers

information between devices.

The information could be a data, it could be address, or it could be some control information.

What is a platform bus? Platform bus is a terminology used by Linux device model to represent

all non-discoverable buses of an embedded platform.

Basically, it's a pseudo bus or a Linux's virtual bus.

Let's explore more about platform bus. So, as I said, a platform bus is a pseudo bus or virtual bus.

Actually, it doesn't have any physical existence.

This is actually a linux terminology to represent bus the interfaces, which don't have auto discoverable

and hot plugging capability.

If you consider a PC scenario, there is a central bus system, which is always based on PCI or PCI express bus. So, the Linux knows that bus.It's a known bus to the Linux or any operating system. The devices which are connected over PCI bus interface are actually auto discoverable and the bus supports hot plugging of devices.

When an operating system such as Windows or Linux runs on your PC, the OS learns about the connected

peripherals automatically.

Same is true for USB.

This is what we call as device discovery. That means, the operating system comes to know about the

devices automatically.

You need not to feed the information about the devices manually.

For example, here, the Wifi card is connected to the PCI Bus, right?

So, the Wifi cards host bus is PCI. And the PCI has inbuilt capability to discover this Wifi card automatically

by accessing its configuration space or what we call as a configuration registers.

You need not to write any piece of code to add the Wifi card details to the kernel manually. Everything happens at the hardware level.

So, when the kernel detects that Wifi card, for example, the kernel automatically loads the driver,

which is incharge of that Wifi card.

And the driver configures the Wifi card and it is ready to use.

Same is true for USB. In USB also, so whenever you connect or remove a USB device the information you know flows through the bus at the hardware level.

That's how, bus comes to know about what kind of hardware is connected to the USB bus.

But, if you consider Embedded platfrom, the bus interfaces on the SOC or on a microcontroller is

purely vendor specific. Different vendors have their own proprietary design for interconnection

of devices and peripherals with the processor.

There is no central bus system such as PCI to discover all On chip as well as Off chip devices.

If you take the example of simple microcontroller such as, let's say STM32, which is based on

ARM Cortex-M architecture. There is the central bus system, which is based on AHB or APB bus protocol

where various On chip peripherals are hanging, such as GPIO controllers I2C, SPI controllers,

USB controllers, etc.. Through these interconnections the processor talks to the peripherals.

If you consider PIC microcontroller, it has got its own bus interfaces.

If you consider a some complex SOC such as a am335x from Texas Instruments, which is actually

being used in our Beagle bone hardware. So, they have their own interconnections and bus protocols.

All these different bus interfaces of an Embedded platform, they neither support a hot plugging nor the auto discovery of connected devices. And almost all the On chip peripherals of an SOC in the embedded world are fixed.

So then, why would you need a bus interface such as PCI?

So, you're not going to remove any On chip peripherals from the SOC, like I2C controller, SPI controller, Serial Port controller, so they are going to be there on the SOC permanently, isn't it?

So, since everything is permanently embedded. So, it doesn't make any sense to implement PCI bus a inside an SOC.

And apart from this, the Embedded platform also has other bus interfaces like I2C, UARTs, SPI

SDIO, etc. So, all these buses they don't support hot plugging or device enumeration.

Linux gives a common name to all these non-discoverable bus and that name is Platform Bus.

So, from the linux point of view, all these devices which are non discoverale are connected to the

processor via the platform bus. Linux doesn't care whether it is a I2C, or it's a AHB, APB, or

L3 interconnect, or L4 interconnect.

So, it doesn't distinguish like that.

From the hardware point of view, yes, they are connected to different bus interfaces. But from

the Linux point of view, it is just a platform bus. A common terminology used by the Linux.

For linux, it just platform bus.And the devices which are connected to the platform bus are called as platform devices or non-discoverable devices. All platform devices are non-discoverable.

In this diagram, you can say that, the I2C controller what you see inside the SOC is a platform device. And this I2C controller controls this I2C bus, which has got two I2C devices.

Let's say, it's a Lm temperature sensor and let's say it is RTC device.Both

these devices are also called as platform devices. Because, for the simple reason, they are not discoverable from their host bus interface.

This platform device analogy makes Linux device model design a pretty much simple and also avoides lots of code duplications. So, to conclude a platform bus is a pseudo bus, from the linux design point of view it is actually a collective name given by the Linux to all passive bus interfaces.

And linux device model considers all these non-discoverable devices are connected to the CPU over this platform bus. Now, let's understand what exactly the device discovery.

Let's understand discovery of devices.

What exactly is this?

Every device has its configuration data and resources, which need to be reported to the OS, which is

running on the computer system. An operating system such as a Windows or Linux, running on the computer,

can auto-discover these data. Thus the OS learn about the connected devices automatically.

This is what we call as device enumeration. Device

enumeration is nothing but it's a process through which the OS can inquire and receive information,

such as the type of the device, the manufacturer, device configuration, and all the devices connected

to a given bus.

Once the OS gathers information about a device, it can autoload the appropriate driver for the device. In

the PC scenario, everything is automated. Because, of the bus interfaces such as PCI and USB, because they

support auto enumeration and hot plugging of devices.

However, on embedded systems platforms, this may not be the case since most peripherals are connected

to the CPU over buses that don't support auto-discovery or enumeration of devices. We call them as

platform devices, isn't it?

And most of the time, since all the On chip peripherals are already permanently embedded inside the SOC, there

is no requirement of hot plugging.

That's why, the embedded platforms bus interfaces is quite different from the PC scenario.

All these platform devices which are non-discoverable by nature, but they must be part of the Linux

device model,

so the information about these devices must be fed to the Linux kernel manually either at compile

time or at boot time of the kernel.

Let's see, what are those device information. Device information

could be many.

So, here I have a listed a couple of points.

It could be Memory or I/O mapped base address and range information,

it could be IRQ number on which the device issues interrupt to the processor, device identification information,

DMA channel information, device address, Pin configuration, power and voltage parameters, and other

device specific data.

So, when you add a platform device to the linux kernel, you should provide all or some of these information

to the next kernel, so that it can load the appropriate

driver and the driver can extract these information and it can configure the device properly.

Let's see, how to add platform devices information to the kernel.

There are many different ways, but let's discuss two important ways.

One is during compilation of the kernel and second one during kernel boot, that is using a device tree blob.

During compilation of the kernel, this is actually a static method, hardware details are part of

a kernel files, a kernel files could be board files, drivers or any set of file.

This is actually deprecated and not recommended.

Second one is you can load dynamically.

That means, you can write a small kernel module, where you can include all the information about the platform

devices, and then you load that module to the kernel.So, that you can feed all platform device information

to the kernel.

And the third one is during kernel boot using device tree technique.

This is very latest and recommended.

In this course, I'm going to cover both deprecated way as well as the latest device tree way. We are going

to see both ways to add the platform devices to the kernel. So, what is a Board file approach?

This method was used before the kernel version 3.7 to add hardware configuration details to the

kernel.

That is details about the onboard as well as offboard peripherals, a pin configuration details, everything

was a part of the board file.

You have to recompile the kernel if any device property changes. And all information about hardware configuration

was hardcoded in the kernel spurce files and board files.

This was the biggest disadvantage of this board file method.

All the hardware configuration of different boards our part of or they were hardcoded in the linux

kernel source files and in some other a set of files.

That's why, whenever you add any new device or if you make changes to any device property, then you

had to rebuild the whole kernel, reload it, and everything had to be restarted again.

That was the a problem with this a board file approach.

That's why, the device tree methods was introduced in newer kernel versions.

The details about the hardware configuration of different boards now lie outside the kernel source file.

The device tree was a originally created by Open Firmware as a part of the communication method for passing

data from Open Firmware to a client program.So, quick the client program, in our case is an operating system.

An operating system a used the device tree to discover the topology of the hardware at runtime, and

thereby support a majority of available hardware without hard coded information.

This method avoided hard coding device

information into the kernel source files.So, the device tree is actually a text file, where you need to follow some syntax

to encode the information of your hardware.

And later you have to compile that device tree file to create a device tree binary, which the kernel

is going to a parse it and it is going to extract the encoded hardware information. Device

tree is a method to encode your

hardware specific details.

If you want to understand more about device tree, then this is a very good place in the kernel documentation

you need to read this document. So, from which I have a taken this slide information.

Don't worry about device tree as of now, because I'm going to cover device tree in this course. And this

course also covers a writing device trees and using a device trees to supply hardware information to the linux kernel

and to your driver.

Here, I have a linux kernel source, so the version is little old, it is 3.16.

And here you can see that, they have used the board file method.

Let's go into the SOC specific folder.

I'm going to arch, arm,

mach-omap2.

And here you can see various board files.

There is a board file for beagle board hardware, so there is a board file for a pandora board,

there is a board file for a touchbook,

this is a board file for devkit8000.

Now, if you open that board file, you see here, all hardcoded pin configuration details

and the platform a device information which are hard coded, and every platform device has its own

platform data,

here is a platform data.

So, everything was hard coded.

After that, this board file calls something called a platform_add_devices.

Whenever the Linux kernel detects a board, let's say, the board could be devkit8000. Whenever

the Linux kernel detects that, the Linux kernel jumps to this function in the board file.Where this function then adds a all

it's on chip as well as off chip peripherals to the kernel as platform devices.

Along with platform devices, the board file also mentions the resources what it consumes as well as

platform specific data.

If you take a look into the same folder in newer kernel versions, you see all these board files have

been removed.

Here is a newer kernel version 4.14.

And if you see the same folder, you can see that, there is only one a generic board file now. Other platforms

specific or board specific

board files have been removed.

If you open this generic and you see, now it is pretty simple and it supports various boards and the

on board peripheral details now have been instantiated from the device tree file.

You don't see any platform device structure here, to represent a platform device.

Don't worry,

so we'll see more on a device tree little later.

We have a separate lecture series for device tree.

Let's move forward.

In summary, what are platform devices? Devices which are connected to the platform bus are called

platform devices. A device if its parent bus doesn't support enumeration of connected devices, then it

becomes a platform device. So, you should keep this in mind.

What is platform driver? A driver who is in charge of handling a platform device is called a platform

driver. In the next lecture,

a will see some examples of platform drivers.

I will see you in the next lecture.

