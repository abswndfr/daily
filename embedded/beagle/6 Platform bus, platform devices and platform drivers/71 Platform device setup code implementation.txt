
Hey, welcome back to the lecture.

So, let's start doing this exercise.

Now, let's create one more project,I call it as 004_pcd_platform_driver.

Here, let's create 2 .c files. One for our platform driver and another one for our a platform

device setup.

I call it as pcd_driver or let me call it as

pcd platform_dricer.c, and another one is pcd_device_setup.c.

First, I'm going to code pcd_device_setup.

So, now first let's include some header files here #include linux/module.h.

And let's see later whether we need more header files or not.

The important thing, what we're going to do in this a file is, we are going to create two platform devices.

First thing is, create 2 a platform devices.

You know that, you know struct platform device represents a platform device.

Let's do that.

Let's create two instances of a struct platform device.

struct platform_device. I call it as

platform_pcdev_1.

Let's initialize this platform_device.

Here, you have to initialize couple of things, but for a time being, let's only initialize the

name field of the struct platform_device.

Let's give one name to the platform_device.

Later this name will be used for the device and driver matching.

Here, let's initialize the name field is equal to, I give the name

pseudo-char-device.

For a time being, I'm going to initialize only one member element of this a platform_device.

Let's create one more platform_device. Because, we are going to add 2 platform_devices.

Name of this device also will be same as before.

pseudo-char-device.

After that, now let's initialize this id field as well.

This is id 0.

I call it as id = 0 here, so I have to you comma here and this will be id =1.

In a group of platform devices, this id can be used as an index.So, this platform pcdev_1

at the 0th index.This platform pcdev_2 will be at first index.

So, the id field can be used for the purpose of indexing.

We created two platform devices and now let's write our modules init and cleanup function, I call

it as static int_init.

pcdev

platform_init.

For a time being, let me return 0 here, that is success.

And after that, let's implement the

cleanup function pcdev_platform_exit.

module_init

pcdev_platform_init.

module_exit(pcdev_platform_exit).

So, MODULE_DESCRIPTION is,

"module which registers platform devices".

So, that much is sufficient.So, after that, let's register our platform device.

Here, in the module_init, we are going to register our platform device. Register platform device.So, the API,

which we are going to use in platform_register_device.

I hope so.

Let's search platform

device

register.

You have to call platform_device_register, add a platform-level device, so you have to pass the

pointer to your platform device.Sorry,

this is platform_device_register.

The pointer to your device.

And after that, let's add another one.

Later will see how to add all the devices in one go. For a time being, let's tick to this function.

This is pcdev_2.

All these a structures like struct platform_device and the prototype of these a

platform_device_register, everything is in the header file platform_device.h.

You have to add that header file.

I'm going to add hash #include linux/platform

device.h.

Whenever you unload the module, so you are going to unregister or remove these a platform devices.For

that, you are going to use

platform_device_unregister.

So, now let's compile this code, let's see what happens.

Let me copy the make file from our previous project.

The file name will be pcd_device_setup.

Yes, the module builds, no problem.So, in the previous exercise, you actually created a stru cture to

represent device private data.

In our case, the private data of a device is

it's a buffer information, a size,

serial_number,

and permission.

In this platform driver exercise, you need to supply all device specific data to the platform driver.

That means, when you register your platform device you have to register the device private data also.That

what we call in this context as device platform data.

Whether a data becomes a platform data or not, that depends on your project.

Let's take an example of permission.

The permission it could be a platform specific data or may not be a platform specific data, that depends

on a agreement between a driver and a device.You cannot strictly segregate something is a platform

data and something is not a platform data.

For this exercise, let's consider the size, serial number, and the permission as platform data.

And while registering our platform device, we have to register these information also.And let's do that.

Let's create a structure for the platform data.

What I'm going to do now here is, I'm going to create one header file called platform.h.

And here, I'm going to create one structure struct pcdev_platform_data.

And this function comprises of size,

another member element to store permission, and a constant char pointer to store the serial_number.

So, these three information will be the platform data of a device in this exercise.

I'm going to save this.

And let me open our pcd_device_setup.c. Here, let's include

the header file platform.h.

And after that, here let's create platform data.

Create 2 platform data.

I call it as 2 here. struct

pcdev_

platform_data, let's create two instances.So, I'm going to create an array.

pcdev_pdata. I call it as pdata, that stands for platform data. So, I create an array of 2. Because,

we have got two devices is equal to.

I'm going to initialize the first array element, that is 0th array element=

size of pcdev_0 let's say.So, I am going to choose something else 512, and next member element

is permission = let's say RDWR, and the serial_number.

You can save some serial_number here.

Let me call it as PCDEVABC1111 something like that, and end this initialization,

let's initialize the next array element =

size for this I'm going to choose 1024, permission as read-write,

serial_number =

PCDEVXYZ2222 something like that.

And after that, let's end this initialization.

Now, this platform data should be included in your platform device.

That's how, your platform device is going to supply that data to the driver when the matching happens.

Let's again get back to this structure definition to see where we can encode this platform_data.

Here you can see that, you don't have any field to encode that information.

Let's go inside this device structure, right here.

So, here is a field to encode the platform_data.Platform specific data

that's why, you can use this field.

What we should be doing now is, let's get back to the code.

Here give comma, you have to dereference the dev field = inside that, there is a field called

platform_data.

Here, you should encode the platform_data. For this device,

I'm going to use the 0th element. pcdev_pdata[0].

And for this device, I'm going to use

dev =

platform_data = &pcdev_pdata[1].

Let's save and exit.

Let's build.

There seems to be some problem.Sorry,

it is actually a platform, form.

Before building this project, let's create a macro, that is a read-write for the permission,

I'm going to create that in platform.h.

And WRONLY 0x10.

Let's build and it compiles, no problem.

Complete upto here and I will see you in the next lecture.