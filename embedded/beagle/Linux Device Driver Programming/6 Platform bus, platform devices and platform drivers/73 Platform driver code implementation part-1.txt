
In the previous lecture, you implemented the device setup file. And we tested adding and removing our

platform devices. Let's go to the second part of the exercise.

Now, we should write platform_driver.

The functionality of a platform driver in this exercise will be same as our previous exercise.

It should create device files,

it should implement read, write, an d other methods,

and the functionality will be the same.

The only difference is now we should implement the probe and remove methods. Because, whenever you load

the platform devices and the platform driver so the matching happens and if the match is detected,

then the probe function will get called.

That's why, I'm going to copy a some code from my previous exercise.

First, let's open our file platform_driver.

So, this is an empty file.

And I'm going to copy some code from my earlier project pcd_n.

This is a skeleton code.

Here, I have init and cleanup functions. And after that, this is a file operation structure, which

is same

and here are the methods. These methods I'm not going to implement, because anyway it will be repetitive,

so I will leave that as an assignment to you.

Let's just complete these a methods. Here,

just a return 0, and for the read I just return 0 here, and for the pcd_write

I just return ENOMEM,

and for the open I just return 0 here.

Let's continue.So, you know that, a platform driver is represented by a structure platform driver.

Let's create a instance of a structure struct platform_driver.

I'm going to do that here before this init function.So,struct

platform_driver, call it as pcd_platform_driver.

And now let's initialize some of the member elements of this structure.

Here is a platform driver structure.So, this structure you can find in platform_device.h.

You have to include this header file.

We are going to initialize this probe and remove a function pointers.And after that, one more important a

member element we have to initialize, that is inside the device driver structure.

Go inside this

and you find a 'name' field here.

This needs to be initialized.With the same value, what you have a used when registering your platform

devices.

When the matching code triggers, so the matching code what it does is, it compares the name field of the

device driver with the name field of the device.And if there is successful comparison, then the probe function

of our platform_driver will get called.

Let's get back to the code.

Here a first thing is probe.Probe is equal to our probe function name will be let's say

pcd_platform_driver_probe, remove function will be

pcd_platform_driver_remove.

And after that, in the drivers structure, we have to initialize the name field.

.name =

pseudo-

char-device. I'm going to use a same name what we used in another file.

After that, let's end this initialization.

And after that, in the init function, we are going to register our driver.For that, I'm going to

call platform

driver_register.

Let's search for that function.

So, the platform_driver_register as I explained in the previous slide, this is actually a macro.

You just have to pass the pointer to your platform_driver here.

&pcd

platform_driver.

Let me just give some message here.

Whenever we unload the module, we are going to a unregister our driver.

That's why, I'm going to call here

platform_driver_unregister.

And I use the same pointer.

Let's implement this probe and remove function, so above this structure.

What's a prototype of the probe function?

Let's check.

This is a prototype.So, the return type should be int and the input argument is a pointer to the detected

platform_device or matched platform_device.

Let's use this prototype.

Int, this is a name,

struct

platform_device *pdev.

For a time being, let's return 0

and the remove function.

So, this remove function gets called when the

device is a removed from the system.

This gets called

when a matched platform device is found.

Let's compile this code, let's see it builds or not. Before that, let's add some header files here.Since you

have used the platform driver structure, you should be adding here include

linux/platform_device.h.

Let's just edit the make file to add our another file

pcd_platform_driver.o.

There seems to be some problem, so these macros are not defined.

For that, I have to include the platform.h.

Here, let's include

platform.h.

Actually it built fine. There is an issue at line number 112, let's check that.

So, this must return integer value here.

The module builds fine, and complete up to here and in the next lectre, let's add more code to this

file.I will see you in the next lecture.