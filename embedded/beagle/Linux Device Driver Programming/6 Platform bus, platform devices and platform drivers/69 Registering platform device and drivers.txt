
So, in this lecture, let's understand how to register a platform device and the platform driver. First,

let's explore registering a platform driver.

You just have to use this 'C' macro to register your platform driver with the Linux platform core.The

macro name is platform_driver_register.That's it. You just have to call this macro

and this macro is defined in linux/platform_device.h.

So, you have to include this header file in your platform driver.

A platform driver is represented by a structure struct platform_driver.

It has couple of a member elements here, some of them are mandatory to initialize all this a member initialization

we'll see when we code for our exercise on platform driver.

Basically, it has a couple of function pointers to initialize and it has got the id_table, which you

need to initialize.And after that, you need to initialize some member elements of the device driver

structure, which is embedded in the struct platform driver. But, for the time being, just aware of

this a structure.

This is a structure to represent a platform driver.

Similarly, you use a platform device register function to register your platform device.

This API you can call from your device setup file, or from the board file, or

you can somehow call this a function to register your platform device.

Basically, it's deprecated method, but understanding this method reveals lots of useful information.

That's why, I will first cover the deprecated one and the later will explore the device tree method.

A platform

device is represented by struct platform_device structure.

It also has got a lots of member elements here, and some are a not that important and some member elements a

need to be initialized.

So, which will explore when we code for our exercise.

Let's explore how a matching between platform device and driver happens. Now you understood, how

to register a platform device and platform driver with the Linux kernel.

You just have to call those a APIs, such as platform driver register and platform

device register. If you just call those APIs, you will register your platform device or platform driver.

Now, let's attend a very important question.

The question is, how does the driver know that you have added exactly the same device which the driver

is looking for so that it can configure the device?

Or how do you make the correct driver gets autoloaded whenever you add the new platform device?

The answer to this question is due to the "matching" mechanism of the platform bus core.

You already know that, a platform driver takes care of a platform device.

Whenever you add a platform device a correct driver has to be autoloaded to configure that device.

That means, at the background there should be some kind of matching mechanism,

someone has to match it.

A match should be established between a platform device and its a corresponding platform driver.

That matching is taken care of by the Linux kernel itself,

you need not to worry about that.

You just have to follow some rules while registering a platform device and a driver, so which you will see

later.

So, this is how the matching works.

Let's take the case of a platform bus. The Linux platform

implementation or the Linux platform core implementation maintains platform device and driver

lists.Whenever you add a new platform device or driver, this list gets updated and matching mechanism

triggers.

Here, when you add a new platform driver, that driver will get added to the driver list of the platform

bus.

And when you add a new platform device, that platform device will get added to the device list, which

is maintained by the Linux platform core.

Remember that, every bus type has it's match function, so where the device and driver list will be scanned. Let's

see an example of matching.

There are different types of matching. A simple "name" based matching, id_table matching, device tree

compatible string matching,

but the core concept is same.

Let's say, there is a platform bus and the platform bus comes with the 2

list. One is device list and another one is driver list.

And let's say, there are already 3 platform drivers present in the driver list.

So, let's say, the name of the first driver is "xyz",

the name of the second driver is "nmo", and the name of the third driver is "abc".

When you add a new device to this platform core what happens? That device will get hooked into the

device list of the platform bus, and the matching mechanism triggers.

So, the name of this newly added device is compared with each and every driver of the driver list. And you

can see that, there is a match. The name of this device matches with name of this driver.

That means, a match is detected here.

So, when the match is detected, the bus driver management code of the Linux kernel decides that this

is a driver which is in charge of this newly added device.

Hence, the probe function of this driver will get called with this device as an argument. The probe

function you must implement in your driver, that will see later.

That's how a simple "name" based matching works.

Let's take another example.

Now, let's say, there are already three devices

present in the device list of the platform bus, and there are already two a drivers present in the

driver list of the platform bus.

Let's say, you add a new driver. When you add a new driver, again the matching mechanism triggers.

Now, let's say the name of this driver is 'xyz'

and these are the names of the platform devices. The matching function of the platform bus triggers

and here is a match detected, xyz and with this device.

There is a match detected.

So, the probe method of this driver will get called with the p.dev-2 as an input argument.

That's how a platform driver binds with the platform device.

Please remember these points. Whenever a new device or a new driver is added, the matching function

of the platform bus runs,

and if it finds a matching platform device for a platform driver, the probe function of the matched driver

will get called. Inside the probe function, the driver configures the detected device.

Details of the matched platform device will be passed to the probe function of the matched driver so

that the driver can extract the platform data and configure it.

Basically, while you register your platform driver, you should mention your probe function a in this function

pointer. So, that will see when we attempt an exercise.

Let's understand, what exactly we do inside the probe function of the platform driver.

Probe function must be implemented by the platform driver and should be registered during

platform_driver_register(). When the bus matching function detects the matching device and driver, the probe function

of the driver gets called with detected platform device as an input argument.

And note that probe() should in general, verify that the specified device hardware actually exist.

Sometimes platform setup code can't be sure.

The probing can use device resources, including clocks, and device platform_data.

So, the probe function is responsible for device detection and initialization, allocation of memories

for various data structures, mapping i/o memory, registering interrupt handlers, registering device

to kernel framework, user level access point creations, etc..

All these things you can do inside the probe function.So, the probe function may return 0, that indicate

success or error code.If probe function returns

a non-zero value, meaning probing of a device has failed.

There is one more important function you need to implement inside your platform driver,

that is remove function.

So, remove function gets called when a platform device is removed from the kernel to unbind a device

from the driver or when the kernel no longer uses the platform device.

The remove function gets called when a platform device is removed from the kernel.

This gets called basically to unbind a device from the driver, or when the kernel no longer uses that

platform device, then the remove function gets called. Remove function is responsible for unregistering

the device from the kernel framework.

Basically, you should be doing some undoing work here, of what you have already done in the probe function.

Like unregistering the device from the kernel framework, a freeing memory allocated on behalf of the device,

Shutting down of the device or De-initializing the device.

Basically, providing probe and remove are mandatory, you should mention them here. And there are some

optional methods you can implement, that is shut down, suspend, and resume. So, most of the information

in this slide has been taken from a the kernel documentation platform.txt.

So, you should visit a this kernel documentation, if you need more information. In the next lecture,

let's see how to implement a platform driver, and I'll see you in the next lecture.

