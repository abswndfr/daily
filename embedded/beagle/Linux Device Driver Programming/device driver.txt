Connection establishment between device file access and the driver							105
 • Create device number															dev_t
 • Create device files															class/device_create -> dev/xxx
 • Make a char device registration with the VFS (CDEV_ADD)						cdev_init/add
 • Implement the driver’s file operation methods for open, read, write, etc		fops
 
 
Kernel APIs and utilities to be used in driver code											106

  alloc_chrdev_region();		1. Create device number

  cdev_init();					   create cdev structure and init it.
  cdev_add();					2. Make a char device registration with the VFS (CDEV_ADD)

  class_create();				3. Create device files 
  device_create();


Kernel APIs and utilities to be used in driver code											107

  ** Creation **				** Deletion **
  alloc_chrdev_region();		unregister_chrdev_region();
  
  cdev_init();					
  cdev_add();					cdev_del();
  
  class_create();				class_destroy();
  device_create();              device_destroy()


  . Dynamically register a range of char device numbers										109

	alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name);
	
	ex. 127:0 ~ 127:6
	
		dev_t 	     *dev 			output parameter for first assigned number		127
		unsigned 	  baseminor     first of the requested range of minor numbers	0
		unsigned 	  count         number of minor numbers required				7
		const char   *name          name of the associated device or drive			"eeprom"
	
	
	alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name);
	




  . Initialize a cdev structure																114

	void cdev_init(struct cdev *cdev, const struct file_operations *fops)
	{
		memset(cdev, 0, sizeof *cdev);								*
		INIT_LIST_HEAD(&cdev->list);
		kobject_init(&cdev->kobj, &ktype_cdev_default);
		cdev->ops = fops;											*
	}
				
	struct cdev *cdev 					structure to initialize : owner, dev #, fops
	
		struct cdev {																		119
			struct kobject kobj;
			struct module *owner;								* THIS_MODULE
			const struct file_operations *ops;					*
			struct list_head list;
			dev_t dev;
			unsigned int count;
		} __randomize_layout;

	const struct file_operations *fops  File operations for this device			=> VFS		117

		struct file_operations {
			struct module *owner;

			loff_t (*llseek) (struct file *, loff_t, int);
			ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
			ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
			int (*open) (struct inode *, struct file *);
			int (*release) (struct inode *, struct file *);

			int (*flush) (struct file *, fl_owner_t id);
			int (*fsync) (struct file *, loff_t, loff_t, int datasync);
			int (*fasync) (int, struct file *, int);
			int (*lock) (struct file *, int, struct file_lock *);

			int (*mmap) (struct file *, struct vm_area_struct *);
			unsigned (*mmap_capabilities)(struct file *);	// #ifndef CONFIG_MMU

			long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
			long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
			...
		} __randomize_layout;

  . Add a char device to the Kernel VFS														121

	int cdev_add(struct cdev *p, dev_t dev, unsigned count);
	
	  struct cdev *p, 	  cdev structure for the device
	  dev_t dev,          number of consecutive minor numbers corresponding to this device
	  unsigned count      first device number for which this device is responsible
		
		
		
		
		
	
  . Dynamically register a range of char device numbers										124	

	  • In Linux, you can create a device file dynamically(on demand), i.e you need not manually
	    create the device files under /dev directory to access your hardware. (This is done by uDevd from sysfs)
	  
	  • User-level program such as udevd can populate /dev directory with device files 
	    dynamically
	  
	  • udev program listens to the uevents generated by hot plug events or kernel modules.
	    When udev receives the uevents, it scans the subdirectories of /sys/class looking for the
	    ‘dev’ files to create device files.
	  
	  • For each such 'dev' file, which represents a combination of major and minor number for
	    a device, the udev program creates a corresponding device file in /dev directory

  . udev 										: user level daemon

	  • So, udev relies on device information being exported to user space through sysfs

	  • uevents are generated when device driver takes the help of kernel APIs 
	    to trigger the dynamic creation of device files or when a hotpluggable device 
		such as a USB peripheral is plugged into the system

  . Dynamic device file creation in Linux

	  • All that a device driver needs to do , for udev to work properly with it, 
	    is ensure that any major and minor numbers assigned to a device controlled by the driver 
		are exported to user space through sysfs.
		
	  • The driver exports all the information regarding the device such as device file name,
	    major , minor number to sysfs by calling the function device_create
		
	  • udev looks for a file called ‘dev’ in the /sys/class/ tree of sysfs, 
	    to determine what the major and minor number is assigned to a specific device




  . class_create and device_create															127

	class_Create:
	
	  Create a directory in sysfs : /sys/class/<your_class_name>		; and register a class with sysfs
	
	
	struct device *device_create(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...);

	  struct class 	*class 		pointer to the struct class that this device should be registered to 
	  struct device *parent 	pointer to the parent struct device of this new device
	  dev_t 		 devt 		dev_t for the char device to be added
	  void 			*drvdata 	data to be added to the device for callbacks
	  const char 	*fmt, ...	string for the device's name

	  ex. struct device *eeprom_dev;
	
	   eeprom_dev = device_create(eeprom_class, NULL, device_number, NULL, "eeprom");
		

	  This function creates a subdirectory under /sys/class/<your_class_name> with your device name.
	   => populates the sysfs class with deivce numbers and device names
	   
	  This function also populates sysfs entry with dev file which consists of the major and minor numbers, separated by a : character


		class_create
		  -> xxx, class name under /sys/class
			  -> device_Create 
			      -> yyy, device name under /sys/class/xxx 			      
			            -> uEvents 								<= hot plug events or .ko
						   -> udevd				               
							   -> scan 'dev' 			; M:m
									-> yyy under /dev	; /dev/yyy 
								







  Character driver file operation methods													134

  Open																						137
  Inode object																				139
  File object																				140
  open flow																					143
  summary																					148			
  


  open																						149
  close																						151
  read																						154
  write																						158
  llseek																					161	


  cleanup																					165
  
  read implementation																		170
  llseek																					181
  write implementation																		184	



  Pseudo character driver with multiple devices												187
  

  
  Device - Driver data structure															192
  container_of																				199
  f_mode																					207
  
  Platform devices and drivers																209
    
  Device tree																				258
  Device tree overlays																		317
  
  Linux Device model																		341
  
  
  




